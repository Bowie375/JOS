## Questions

1. Q1: What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
    - in current implementation, some handler need to push errno while some don't; also, different handlers correspond to different trapnum. If all exceptions/interrupts were delivered to the same handler, we cannot provide such feature.

2. Q2: Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?
    - Because trigger PG fault need dlp=0, so user program cannot manually trigger it, instead this behavior will end up cause another exception that is "general protection fault"(trap 13). If kernel allow softint's int $14 to invoke kernel's page fault handler, malicious programs can use it to compromise the kernel by trying to dereference an address in unknown kernel space.

3. Q3: The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?
    - If I chose to install that handler with dpl=0, then user program cannot trigger it, which results in a general protection fault. If I chose to install that handler with dpl=3, then user program can trigger it, which results in a break point exception. 

4. Q4: What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
    - This mechanism can make the system more safe, and user program cannot trigger some dangerous operations by themselves. 


## Challenges:
I finished the challenge in _Setting Up The IDT_ section, which is:

    **Challenge!** You probably have a lot of very similar code right now, between the lists of TRAPHANDLER in trapentry.S and their installations in trap.c. Clean this up. Change the macros in trapentry.S to automatically generate a table for trap.c to use. Note that you can switch between laying down code and data in the assembler by using the directives .text and .data.

I did this by:
- first modify the `TRAPHANDLER` and `TRAPHANDLER_NOEC` macro to automatically add the trap number and handler address to the .data segment. Modification for `TRAPHANDLER` is like:

```
    #define TRAPHANDLER(name, num, dpl)
    .text;	
    	.globl name;
    	.type name, @function;	
    	.align 2;
    	name:
    	pushl $(num);	
    	jmp _alltraps;			
    .data;	// add these two lines
    	.long num, name, dpl, 0	
```

- second, add two tags in the data segment of trapentry.S to organize all handlers in a table-like manner. The modification is like:

```
    .data
    .globl idt_handlers
    idt_handlers:

    TRAPHANDLER_NOEC(trap_divide, T_DIVIDE, 0)

    .data
    .globl idt_handlers_end
    idt_handlers_end:
```

- third, modify the `trap_init` function in trap.c to use the table generated by the macros. The modification is like:

```c
	extern uint32_t idt_handlers[];
	extern uint32_t idt_handlers_end[];

	uint32_t *entry = idt_handlers, trapno, dpl;
	void (*handler)();

	while (entry < idt_handlers_end) {
		trapno = entry[0];
		handler = (void (*)()) entry[1];
		dpl = entry[2];
		SETGATE(idt[trapno], 0, GD_KT, handler, dpl);
		entry += 4;
	}
```

After all these modifications, I can clean up the code in trapentry.S and it will be much easier for me to add new handlers in the future because I only need to change `trapentry.S`, and `trap.c` can be left unchanged.
